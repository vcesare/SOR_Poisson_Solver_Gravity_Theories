/*
  © 2025 Valentina Cesare
  Licensed under the MIT License.
  See LICENSE file for full license text.
*/

// This code finds the QUMOND gravitational potential, φQM, given a Newtonian potential generated by a mass density distribution rho, by numerically solving QUMOND Poisson Equation (∇2φQM = ∇·[ν(|∇φN|/a0)∇φN]; Milgrom, et al. (2010) (https://ui.adsabs.harvard.edu/abs/2010MNRAS.403..886M/abstract); e.g., Eq. (16) in Cesare, et al. (2020) (https://ui.adsabs.harvard.edu/abs/2020A%26A...637A..70C/abstract) over a 3D grid in cylindrical coordinates, (R,z,phi), with Successive-Over-Relaxation (SOR) Poisson Solver. This Poisson Solver is a 3D extension of 2D Poisson Solver described in Appendix B of Cesare, et al. (2020).
// Author: Valentina Cesare.
// E-Mail address: valentina.cesare@inaf.it
// Creation date: July 31th 2025.

// The Poisson Solver for the density distribution considered in this code converges in 16239 iterations.

#include <cstdlib>
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <iostream>
#include <cmath>
#include <random>
#include <iomanip>
#include <fstream>

using namespace std;

double nu(double y);

double Error(double ***V, double ***V_New);
//double ErrorResiduo(double dR, double dR2, double dz2, double dphi2, double *R, double ***phi, double ***S);


//    Number of grid points
#define NR 301
#define NZ 300
#define NPHI 100

//#define NR 101
//#define NZ 100
//#define NPHI 30

int main()
{
//    pi
    const double CONST_PI = 3.14159265358979;
// Universal gravitational constant expressed in (kpc/Msun)*(km/s)^2
    const double G = 4.3011e-6;
    
//    MOND critical acceleration expressed in (1/kpc)*(km/s)^2
    const double a0 = 3600.0;
    
//    The grid along R and z is in kpc.
    double xbeg = -30.0, xend = 30.0;
    double zbeg = -30.0, zend = 30.0;
//    The grid along phi is in radians.
    double phibeg = 0.0, phiend = 2.0*CONST_PI;
    
    double dx = (xend-xbeg)/double(NR);
    double dz = (zend-zbeg)/double(NZ);
    double dphi = (phiend-phibeg)/double(NPHI);
    
    double dx2 = dx*dx;
    double dz2 = dz*dz;
    double dphi2 = dphi*dphi;
    
    double x[NR + 1], z[NZ + 1], phi[NPHI];
    
    int Nmin;
    Nmin = NR;
    if (Nmin > NZ)
        Nmin = NZ;
        
    if (Nmin > NPHI)
        Nmin = NPHI;
    
    cout<<"Nmin = "<<Nmin<<endl;
    
//    Parameter that regulates the convergence and the speed of SOR Poisson Solver.
    double wsor = 2.0/(1.0 + CONST_PI/Nmin);
    cout<<"wsor = "<<wsor<<endl;
    
//    Speed experiments with other wsor values:
//    double wsor = 1.75;
//    double wsor = 1.25;
//    double wsor = 1.01;
//    double wsor = 1.7;
    
    // Initialize grid (x and z grids are in kpc, phi grid is in radians.
    for (int i = 0; i <= NR; i++) x[i] = xbeg + i*dx;
    for (int k = 0; k <= NZ; k++) z[k] = zbeg + k*dz;
    for (int j = 0; j < NPHI; j++) phi[j] = phibeg + j*dphi;
    
    for (int i = 0; i <= NR; i++)
        cout<<"x["<<i<<"] = "<<x[i]<<endl;
    
    for (int k = 0; k <= NZ; k++)
        cout<<"z["<<k<<"] = "<<z[k]<<endl;
    
    for (int j = 0; j < NPHI; j++)
        cout<<"phi["<<j<<"] = "<<phi[j]<<endl;
    
    double R[NR + 1];
    for (int i = 0; i <= NR; i++) R[i] = abs(x[i]);
    
//    Files writing are for plots (if you do not need them, you can comment them out).
    ofstream outfileRHalf ("R_Half.txt");
    {
        for(int i = (NR - 1)/2 + 1; i <= NR; i++) outfileRHalf<<R[i]<<endl;
    }
    outfileRHalf.close();
    
    ofstream outfileR ("R.txt");
    {
        for(int i = 0; i <= NR; i++) outfileR<<R[i]<<endl;
    }
    outfileR.close();
    
    ofstream outfilez ("z.txt");
    {
        for(int k = 0; k <= NZ; k++) outfilez<<z[k]<<endl;
    }
    outfilez.close();
    
    ofstream outfilephi ("phi.txt");
    {
        for(int j = 0; j < NPHI; j++) outfilephi<<phi[j]<<endl;
    }
    outfilephi.close();
    
    double dR = dx;
    double dR2 = dx2;
    
//    Memory allocation
    double ***phiNTheo, ***dphiNdR, ***dphiNdz, ***dphiNdphi, ***modgradphiN, ***d2phiNdR2, ***d2phiNdz2, ***d2phiNdphi2, ***dnudR, ***dnudz, ***dnudphi, ***SQUMOND, ***phi0, ***phi1;
    phiNTheo=new double**[NR+1];
    dphiNdR=new double**[NR+1];
    dphiNdz=new double**[NR+1];
    dphiNdphi=new double**[NR+1];
    modgradphiN=new double**[NR+1];
    d2phiNdR2=new double**[NR+1];
    d2phiNdz2=new double**[NR+1];
    d2phiNdphi2=new double**[NR+1];
    dnudR=new double**[NR+1];
    dnudz=new double**[NR+1];
    dnudphi=new double**[NR+1];
    SQUMOND=new double**[NR+1];
    phi0=new double**[NR+1];
    phi1=new double**[NR+1];
    for(int i = 0; i <= NR; i++)
    {
        phiNTheo[i]=new double*[NZ+1];
        dphiNdR[i]=new double*[NZ+1];
        dphiNdz[i]=new double*[NZ+1];
        dphiNdphi[i]=new double*[NZ+1];
        modgradphiN[i]=new double*[NZ+1];
        d2phiNdR2[i]=new double*[NZ+1];
        d2phiNdz2[i]=new double*[NZ+1];
        d2phiNdphi2[i]=new double*[NZ+1];
        dnudR[i]=new double*[NZ+1];
        dnudz[i]=new double*[NZ+1];
        dnudphi[i]=new double*[NZ+1];
        SQUMOND[i]=new double*[NZ+1];
        phi0[i]=new double*[NZ+1];
        phi1[i]=new double*[NZ+1];
        for(int k = 0; k <= NZ; k++)
        {
            phiNTheo[i][k]=new double[NPHI+1];
            dphiNdR[i][k]=new double[NPHI+1];
            dphiNdz[i][k]=new double[NPHI+1];
            dphiNdphi[i][k]=new double[NPHI+1];
            modgradphiN[i][k]=new double[NPHI+1];
            d2phiNdR2[i][k]=new double[NPHI+1];
            d2phiNdz2[i][k]=new double[NPHI+1];
            d2phiNdphi2[i][k]=new double[NPHI+1];
            dnudR[i][k]=new double[NPHI+1];
            dnudz[i][k]=new double[NPHI+1];
            dnudphi[i][k]=new double[NPHI+1];
            SQUMOND[i][k]=new double[NPHI+1];
            phi0[i][k]=new double[NPHI+1];
            phi1[i][k]=new double[NPHI+1];
        }
    }
    
//    Reading of file containing the full (axisymmetric Miyamoto-Nagai + spiral arms) theoretical Newtonian potential written by code "Newton_Axisymmetric_MN_Disk_Plus_Spiral_Arms_Model.cc". Since Newtonian potential is analytically computable, it is sufficient to import the Newtonian analytical potential to be used in QUMOND Poisson Equation source term. If, considering another density distribution, Newtonian potential is not analytically computable, Newtonian and QUMOND Poisson Solvers must be executed in sequence.
    ifstream infilephiNTheo ("phiNTheo_MNPlusSpiral_Smooth_Cutoff.txt");
    {
        for(int i = 0; i <= NR; i++)
        {
            for(int k = 0; k <= NZ; k++)
            {
                for(int j = 0; j < NPHI; j++)
                {
                    infilephiNTheo>>phiNTheo[i][k][j];
                }
            }
        }
    }
    infilephiNTheo.close();
    
    
//    Usage of Leap Frog method to compute first derivates of phiNTheo  discretized on computational (R,z,phi) grid.
    for(int i = 1; i < NR; i++)
    {
        for(int k = 0; k <= NZ; k++)
        {
            for(int j = 0; j < NPHI; j++)
            {
                dphiNdR[i][k][j] = (phiNTheo[i+1][k][j] - phiNTheo[i-1][k][j])/(2.0*dR);
            }
        }
    }
    
    for(int i = 0; i <= NR; i++)
    {
        for(int k = 1; k < NZ; k++)
        {
            for(int j = 0; j < NPHI; j++)
            {
                dphiNdz[i][k][j] = (phiNTheo[i][k+1][j] - phiNTheo[i][k-1][j])/(2.0*dz);
            }
        }
    }
    
    for(int i = 0; i <= NR; i++)
    {
        for(int k = 0; k <= NZ; k++)
        {
            for(int j = 1; j < NPHI - 1; j++)
            {
                dphiNdphi[i][k][j] = (phiNTheo[i][k][j+1] - phiNTheo[i][k][j-1])/(2.0*dphi);
            }
        }
    }
    
//    BOUNDARY CONDITIONS FOR dphiNdR, dphiNdz, AND dphiNdphi, NECESSARY SINCE dphiNdR|0,k,j ; dphiNdR|NR,k,j ; dphiNdz|i,0,j ; dphiNdz|i,NZ,j ; dphiNdphi|i,k,0 ; dphiNdphi|i,k,NPHI-1 CANNOT BE CALCULATED WITH LEAP FROG METHOD (THE THREE FOR LOOPS ABOVE). THEREFORE, TO DEFINE THESE BOUNDARY CONDITIONS, EULER DISCRETIZATION FOR FIRST DERIVATIVES IS ADOPTED.
    for(int k = 0; k <= NZ; k++)
    {
        for(int j = 0; j < NPHI; j++)
        {
            dphiNdR[0][k][j] = (phiNTheo[1][k][j] - phiNTheo[0][k][j])/dR;
            dphiNdR[NR][k][j] = (phiNTheo[NR][k][j] - phiNTheo[NR-1][k][j])/dR;
        }
    }
    
    for(int i = 0; i <= NR; i++)
    {
        for(int j = 0; j < NPHI; j++)
        {
            dphiNdz[i][0][j] = (phiNTheo[i][1][j] - phiNTheo[i][0][j])/dz;
            dphiNdz[i][NZ][j] = (phiNTheo[i][NZ][j] - phiNTheo[i][NZ-1][j])/dz;
        }
    }
    
    for(int i = 0; i <= NR; i++)
    {
        for(int k = 0; k <= NZ; k++)
        {
            dphiNdphi[i][k][0] = (phiNTheo[i][k][1] - phiNTheo[i][k][0])/dphi;
            dphiNdphi[i][k][NPHI-1] = (phiNTheo[i][k][NPHI-1] - phiNTheo[i][k][NPHI-2])/dphi;
        }
    }
    
//    SYMMETRY OF THE NEWTONIAN DERIVATIVE dphiN/dz BELOW AND ABOVE THE DISK PLANE:
    for(int i = 0; i <= NR; i++)
    {
        for(int k = 0; k <= NZ/2; k++)
        {
            for(int j = 0; j < NPHI; j++)
            {
                dphiNdphi[i][k][j] = -1.0*dphiNdphi[i][k][j];
            }
        }
    }
    
//    MODULUS OF GRADIENT OF NEWTONIAN POTENTIAL IN CYLINDRICAL (R,z,phi) COORDINATES:
    for(int i = 0; i <= NR; i++)
    {
        for(int k = 0; k <= NZ; k++)
        {
            for(int j = 0; j < NPHI; j++)
            {
                modgradphiN[i][k][j] = sqrt(dphiNdR[i][k][j]*dphiNdR[i][k][j] + dphiNdz[i][k][j]*dphiNdz[i][k][j] + dphiNdphi[i][k][j]*dphiNdphi[i][k][j]/(R[i]*R[i]));
            }
        }
    }
    
//    Usage of Leap Frog method to compute the second derivates of phiNTheo discretized on computational (R,z,phi) grid.
    for(int i = 1; i < NR; i++)
    {
        for(int k = 0; k <= NZ; k++)
        {
            for(int j = 0; j < NPHI; j++)
            {
                d2phiNdR2[i][k][j] = (phiNTheo[i+1][k][j] + phiNTheo[i-1][k][j] - 2.0*phiNTheo[i][k][j])/dR2;
            }
        }
    }
    
    for(int i = 0; i <= NR; i++)
    {
        for(int k = 1; k < NZ; k++)
        {
            for(int j = 0; j < NPHI; j++)
            {
                d2phiNdz2[i][k][j] = (phiNTheo[i][k+1][j] + phiNTheo[i][k-1][j] - 2.0*phiNTheo[i][k][j])/dz2;
            }
        }
    }
    
    for(int i = 0; i <= NR; i++)
    {
        for(int k = 0; k <= NZ; k++)
        {
            for(int j = 1; j < NPHI - 1; j++)
            {
                d2phiNdphi2[i][k][j] = (phiNTheo[i][k][j+1] + phiNTheo[i][k][j-1] - 2.0*phiNTheo[i][k][j])/dphi2;
            }
        }
    }
    
//    BOUNDARY CONDITIONS FOR d2phiNdR2, d2phiNdz2, AND d2phiNdphi2, NECESSARY SINCE d2phiNdR2|0,k,j ; d2phiNdR2|NR,k,j ; d2phiNdz2|i,0,j ; d2phiNdz2|i,NZ,j ; d2phiNdphi2|i,k,0 ; d2phiNdphi2|i,k,NPHI-1 CANNOT BE CALCULATED WITH LEAP FROG METHOD (THE THREE FOR LOOPS ABOVE). THEREFORE, TO DEFINE THESE BOUNDARY CONDITIONS, EULER DISCRETIZATION FOR FIRST DERIVATIVES (COMPUTATION OF SECOND DERIVATIVES AS FIRST DERIVATIVES OF FIRST DERIVATIVES) IS ADOPTED.
    for(int k = 0; k <= NZ; k++)
    {
        for(int j = 0; j < NPHI; j++)
        {
            d2phiNdR2[0][k][j] = (dphiNdR[1][k][j] - dphiNdR[0][k][j])/dR;
            d2phiNdR2[NR][k][j] = (dphiNdR[NR][k][j] - dphiNdR[NR-1][k][j])/dR;
        }
    }
    
    for(int i = 0; i <= NR; i++)
    {
        for(int j = 0; j < NPHI; j++)
        {
            d2phiNdz2[i][0][j] = (dphiNdz[i][1][j] - dphiNdz[i][0][j])/dz;
            d2phiNdz2[i][NZ][j] = (dphiNdz[i][NZ][j] - dphiNdz[i][NZ-1][j])/dz;
        }
    }
    
    for(int i = 0; i <= NR; i++)
    {
        for(int k = 0; k <= NZ; k++)
        {
            d2phiNdphi2[i][k][0] = (dphiNdphi[i][k][1] - dphiNdphi[i][k][0])/dphi;
            d2phiNdphi2[i][k][NPHI-1] = (dphiNdphi[i][k][NPHI-1] - dphiNdphi[i][k][NPHI-2])/dphi;
        }
    }
    
    
//    Usage of Leap Frog method to compute first derivates of nu  discretized on computational (R,z,phi) grid.
    for(int i = 1; i < NR; i++)
    {
        for(int k = 0; k <= NZ; k++)
        {
            for(int j = 0; j < NPHI; j++)
            {
                dnudR[i][k][j] = (nu(modgradphiN[i+1][k][j]/a0) - nu(modgradphiN[i-1][k][j]/a0))/(2.0*dR);
            }
        }
    }
    
    for(int i = 0; i <= NR; i++)
    {
        for(int k = 1; k < NZ; k++)
        {
            for(int j = 0; j < NPHI; j++)
            {
                dnudz[i][k][j] = (nu(modgradphiN[i][k+1][j]/a0) - nu(modgradphiN[i][k-1][j]/a0))/(2.0*dz);
            }
        }
    }
    
    for(int i = 0; i <= NR; i++)
    {
        for(int k = 0; k <= NZ; k++)
        {
            for(int j = 1; j < NPHI - 1; j++)
            {
                dnudphi[i][k][j] = (nu(modgradphiN[i][k][j+1]/a0) - nu(modgradphiN[i][k][j-1]/a0))/(2.0*dphi);
            }
        }
    }
    
//    BOUNDARY CONDITIONS FOR dnudR, dnudz, AND dnudphi, NECESSARY SINCE dnudR|0,k,j ; dnudR|NR,k,j ; dnudz|i,0,j ; dnudz|i,NZ,j ; dnudphi|i,k,0 ; dnudphi|i,k,NPHI-1 CANNOT BE CALCULATED WITH LEAP FROG METHOD (THE THREE FOR LOOPS ABOVE). THEREFORE, TO DEFINE THESE BOUNDARY CONDITIONS, EULER DISCRETIZATION FOR FIRST DERIVATIVES IS ADOPTED.
    for(int k = 0; k <= NZ; k++)
    {
        for(int j = 0; j < NPHI; j++)
        {
            dnudR[0][k][j] = (nu(modgradphiN[1][k][j]/a0) - nu(modgradphiN[0][k][j]/a0))/dR;
            dnudR[NR][k][j] = (nu(modgradphiN[NR][k][j]/a0) - nu(modgradphiN[NR-1][k][j]/a0))/dR;
        }
    }
     
    for(int i = 0; i <= NR; i++)
    {
        for(int j = 0; j < NPHI; j++)
        {
            dnudz[i][0][j] = (nu(modgradphiN[i][1][j]/a0) - nu(modgradphiN[i][0][j]/a0))/dz;
            dnudz[i][NZ][j] = (nu(modgradphiN[i][NZ][j]/a0) - nu(modgradphiN[i][NZ-1][j]/a0))/dz;
        }
    }
     
    for(int i = 0; i <= NR; i++)
    {
        for(int k = 0; k <= NZ; k++)
        {
            dnudphi[i][k][0] = (nu(modgradphiN[i][k][1]/a0) - nu(modgradphiN[i][k][0]/a0))/dphi;
            dnudphi[i][k][NPHI-1] = (nu(modgradphiN[i][k][NPHI-1]/a0) - nu(modgradphiN[i][k][NPHI-2]/a0))/dphi;
        }
    }
         
    
//    QUMOND source term of SOR Poisson Solver (Eq. (B.4) in Cesare, et al. (2020)):
    for(int i = 0; i <= NR; i++)
    {
        for(int k = 0; k <= NZ; k++)
        {
            for(int j = 0; j < NPHI; j++)
            {
                SQUMOND[i][k][j] = -((nu(modgradphiN[i][k][j]/a0)/R[i])*dphiNdR[i][k][j] + dnudR[i][k][j]*dphiNdR[i][k][j] + nu(modgradphiN[i][k][j]/a0)*d2phiNdR2[i][k][j] + dnudz[i][k][j]*dphiNdz[i][k][j] + nu(modgradphiN[i][k][j]/a0)*d2phiNdz2[i][k][j] + (dnudphi[i][k][j]*dphiNdphi[i][k][j] + nu(modgradphiN[i][k][j]/a0)*d2phiNdphi2[i][k][j])/(R[i]*R[i]));
            }
        }
    }
    
    
//    POISSON SOLVER BASED ON SOR METHOD:

    int counter = 0;
    double old_err = 1.0e30;
    double err = 1.0e30;
//    double err = 1.0;
    double tol = 1.0e-9;

//    QUMOND potential inizialization.
    for (int i = 0; i <= NR; i++)
    {
        for (int k = 0; k <= NZ; k++)
        {
            for (int j = 0; j < NPHI; j++)
            {
                phi0[i][k][j] = 0.0;
            }
        }
    }


//        Neumann boundary conditions for QUMOND potential.
    
//    BOTTOM
    //                dRphiMONDdR
    for (int i = 0; i < (NR-1)/2; i++)
    {
        for (int j = 0; j < NPHI; j++)
        {
            phi0[i+1][0][j] = phi0[i][0][j] - dR*sqrt(a0/modgradphiN[i][0][j])*dphiNdR[i][0][j];
        }
    }
        
    for (int i = (NR-1)/2 + 1; i <= NR; i++)
    {
        for (int j = 0; j < NPHI; j++)
        {
            phi0[i][0][j] = phi0[NR-i][0][j];
        }
    }
        
    //                dzphiMONDdz
    for (int i = 0; i <= NR; i++)
    {
        for (int j = 0; j < NPHI; j++)
        {
            phi0[i][1][j] = phi0[i][0][j] - dz*sqrt(a0/modgradphiN[i][1][j])*dphiNdz[i][1][j];
        }
    }
     
    
   //                dvarphiphiMONDdvarphi
    for (int i = 0; i <= NR; i++)
    {
        for (int j = 0; j < NPHI/2; j++)
        {
            phi0[i][0][j+1] = phi0[i][0][j] - dphi*sqrt(a0/modgradphiN[i][0][j])*dphiNdphi[i][0][j];
        }
    }
        
    for (int i = 0; i <= NR; i++)
    {
        for (int j = NPHI/2; j < NPHI; j++)
        {
            phi0[i][0][j] = phi0[i][0][NPHI-j];
        }
    }
      
    
//    TOP
    //                dRphiMONDdR
    for (int i = 0; i < (NR-1)/2; i++)
    {
        for (int j = 0; j < NPHI; j++)
        {
            phi0[i+1][NZ][j] = phi0[i][NZ][j] - dR*sqrt(a0/modgradphiN[i][NZ][j])*dphiNdR[i][NZ][j];
        }
    }
        
    for (int i = (NR-1)/2 + 1; i <= NR; i++)
    {
        for (int j = 0; j < NPHI; j++)
        {
            phi0[i][NZ][j] = phi0[NR-i][NZ][j];
        }
    }
        
    //                dzphiMONDdz
    for (int i = 0; i <= NR; i++)
    {
        for (int j = 0; j < NPHI; j++)
        {
            phi0[i][NZ-1][j] = phi0[i][NZ][j] - dz*sqrt(a0/modgradphiN[i][NZ-1][j])*dphiNdz[i][NZ-1][j];
        }
    }
     
    
   //                dvarphiphiMONDdvarphi
    for (int i = 0; i <= NR; i++)
    {
        for (int j = 0; j < NPHI/2; j++)
        {
            phi0[i][NZ][j+1] = phi0[i][NZ][j] - dphi*sqrt(a0/modgradphiN[i][NZ][j])*dphiNdphi[i][NZ][j];
        }
    }
        
    for (int i = 0; i <= NR; i++)
    {
        for (int j = NPHI/2; j < NPHI; j++)
        {
            phi0[i][NZ][j] = phi0[i][NZ][NPHI-j];
        }
    }
    
    
//    LEFT
    //                dRphiMONDdR
    for (int k = 0; k <= NZ; k++)
    {
        for (int j = 0; j < NPHI; j++)
        {
            phi0[1][k][j] = phi0[0][k][j] - dR*sqrt(a0/modgradphiN[1][k][j])*dphiNdR[1][k][j];
        }
    }
    
    //                dzphiMONDdz
    for (int k = 0; k <= NZ/2 - 1; k++)
    {
        for (int j = 0; j < NPHI; j++)
        {
            phi0[0][k+1][j] = phi0[0][k][j] - dz*sqrt(a0/modgradphiN[0][k][j])*dphiNdz[0][k][j];
        }
    }
        
    for (int k = NZ/2; k <= NZ; k++)
    {
        for (int j = 0; j < NPHI; j++)
        {
            phi0[0][k][j] = phi0[0][NZ-k][j];
        }
    }
        
    //    dvarphiphiMONDdvarphi
    for (int k = 0; k <= NZ; k++)
    {
        for (int j = 0; j < NPHI/2; j++)
        {
            phi0[0][k][j+1] = phi0[0][k][j] - dphi*sqrt(a0/modgradphiN[0][k][j])*dphiNdphi[0][k][j];
        }
    }
        
    for (int k = 0; k <= NZ; k++)
    {
        for (int j = NPHI/2; j < NPHI; j++)
        {
            phi0[0][k][j] = phi0[0][k][NPHI-j];
        }
    }
    
    
//    RIGHT
    //                dRphiMONDdR
    for (int k = 0; k <= NZ; k++)
    {
        for (int j = 0; j < NPHI; j++)
        {
            phi0[NR-1][k][j] = phi0[NR][k][j] - dR*sqrt(a0/modgradphiN[NR-1][k][j])*dphiNdR[NR-1][k][j];
        }
    }
    
    //                dzphiMONDdz
    for (int k = 0; k <= NZ/2 - 1; k++)
    {
        for (int j = 0; j < NPHI; j++)
        {
            phi0[NR][k+1][j] = phi0[NR][k][j] - dz*sqrt(a0/modgradphiN[NR][k][j])*dphiNdz[NR][k][j];
        }
    }
        
    for (int k = NZ/2; k <= NZ; k++)
    {
        for (int j = 0; j < NPHI; j++)
        {
            phi0[NR][k][j] = phi0[NR][NZ-k][j];
        }
    }
        
    //    dvarphiphiMONDdvarphi
    for (int k = 0; k <= NZ; k++)
    {
        for (int j = 0; j < NPHI/2; j++)
        {
            phi0[NR][k][j+1] = phi0[NR][k][j] - dphi*sqrt(a0/modgradphiN[NR][k][j])*dphiNdphi[NR][k][j];
        }
    }
        
    for (int k = 0; k <= NZ; k++)
    {
        for (int j = NPHI/2; j < NPHI; j++)
        {
            phi0[NR][k][j] = phi0[NR][k][NPHI-j];
        }
    }
    
    
//    BACK
    //                dRphiMONDdR
    for (int i = 0; i < (NR-1)/2; i++)
    {
        for (int k = 0; k <= NZ; k++)
        {
            phi0[i+1][k][0] = phi0[i][k][0] - dR*sqrt(a0/modgradphiN[i][k][0])*dphiNdR[i][k][0];
        }
    }
        
    for (int i = (NR-1)/2 + 1; i <= NR; i++)
    {
        for (int k = 0; k <= NZ; k++)
        {
            phi0[i][k][0] = phi0[NR-i][k][0];
        }
    }
        
    //                dzphiMONDdz
    for (int i = 0; i <= NR; i++)
    {
        for (int k = 0; k <= NZ/2 - 1; k++)
        {
            phi0[i][k+1][0] = phi0[i][k][0] - dz*sqrt(a0/modgradphiN[i][k][0])*dphiNdz[i][k][0];
        }
    }
        
    for (int i = 0; i <= NR; i++)
    {
        for (int k = NZ/2; k <= NZ; k++)
        {
            phi0[i][k][0] = phi0[i][NZ-k][0];
        }
    }
     
    
   //                dvarphiphiMONDdvarphi
    for (int i = 0; i <= NR; i++)
    {
        for (int k = 0; k <= NZ; k++)
        {
            phi0[i][k][1] = phi0[i][k][0] - dphi*sqrt(a0/modgradphiN[i][k][1])*dphiNdphi[i][k][1];
        }
    }
    
//    PERIODICITY BOUNDARY CONDITION
    for (int i = 0; i <= NR; i++)
    {
        for (int k = 0; k <= NZ; k++)
        {
            phi0[i][k][NPHI - 1] = phi0[i][k][0];
        }
    }
    
//    Sign adjustement of QUMOND potential
    for (int i = 0; i <= NR; i++)
    {
        for (int k = 0; k <= NZ; k++)
        {
            for (int j = 0; j < NPHI; j++)
            {
                phi0[i][k][j] = -phi0[i][k][j];
            }
        }
    }
        
//    SOR POISSON SOLVER WHILE LOOP UP TO CONVERGENCE:
    
    while (err > tol) {
        for(int i = 0; i <= NR; i++)
        {
            for(int k = 0; k <= NZ; k++)
            {
                for (int j = 0; j < NPHI; j++)
                {
                    phi1[i][k][j] = phi0[i][k][j];
                }
            }
        }

        for(int i = 1; i < NR; i++)
        {
            for(int k = 1; k < NZ; k++)
            {
                for (int j = 1; j < NPHI - 1; j++)
                {
                    int jplus  = (j + 1) % NPHI;
                    int jminus = (j - 1 + NPHI) % NPHI;
                    phi1[i][k][j] = phi0[i][k][j]*(1.0 - wsor) + wsor/(2.0 + 2.0*dR2/dz2 + 2.0*dR2/(R[i]*R[i]*dphi2))*((1.0 + dR/(2.0*R[i]))*phi1[i+1][k][j] + (1.0 - dR/(2.0*R[i]))*phi1[i-1][k][j] + dR2/(dphi2*R[i]*R[i])*(phi1[i][k][jplus] + phi1[i][k][jminus]) + (dR2/dz2)*(phi1[i][k+1][j] + phi1[i][k-1][j]) + dR2*SQUMOND[i][k][j]);
                }
            }
        }

        // Compute error.
        err = Error(phi0, phi1);

        //        Algorithm to improve QUMOND SOR Poisson Solver convergence speed.
        if (err > old_err) {
            wsor *= 0.95;
        } else {
            wsor = min(wsor * 1.05, 1.99);
        }
        old_err = err;

        for(int i = 1; i < NR; i++)
        {
            for(int k = 1; k < NZ; k++)
            {
                for (int j = 1; j < NPHI - 1; j++)
                {
                    phi0[i][k][j] = phi1[i][k][j];
                }
            }
        }
        counter++;
        cout <<"counter = "<< counter << "; err = " << setprecision(8) << err << endl;
    }

//    FILE WRITING FOR NUMERICAL QUMOND POTENTIAL.
//    Files writing are for plots (if you do not need them, you can comment them out).
    ofstream outfilephiQUMONDCompR ("phiQUMONDComp_MNPlusSpiral_R_zeq0_phieq0_Smooth_Cutoff.txt");
    {
        for(int i = (NR - 1)/2 + 1; i <= NR; i++) outfilephiQUMONDCompR<<phi1[i][NZ/2][0]<<endl;
    }
    outfilephiQUMONDCompR.close();

    ofstream outfilephiQUMONDCompz ("phiQUMONDComp_MNPlusSpiral_z_Rsimeq0_phieq0_Smooth_Cutoff.txt");
    {
        for(int k = 0; k <= NZ; k++) outfilephiQUMONDCompz<<phi1[(NR - 1)/2 + 1][k][0]<<endl;
    }
    outfilephiQUMONDCompz.close();

    ofstream outfilephiQUMONDCompphi ("phiQUMONDComp_MNPlusSpiral_phi_Rsimeq0_zeq0_Smooth_Cutoff.txt");
    {
        for(int j = 0; j < NPHI; j++) outfilephiQUMONDCompphi<<phi1[(NR - 1)/2 + 1][NZ/2][j]<<endl;
    }
    outfilephiQUMONDCompphi.close();

    ofstream outfilephiQUMONDComp ("phiQUMONDComp_MNPlusSpiral_Smooth_Cutoff.txt");
    {
        for(int i = 0; i <= NR; i++)
        {
            for(int k = 0; k <= NZ; k++)
            {
                for(int j = 0; j < NPHI; j++)
                {
                    outfilephiQUMONDComp<<phi1[i][k][j]<<endl;
                }
            }
        }
    }
    outfilephiQUMONDComp.close();

    
//    MEMORY DEALLOCATION:
    for(int i = 0; i <= NR; i++)
    {
        for(int k = 0; k <= NZ; k++)
        {
            delete[] phiNTheo[i][k];
            delete[] dphiNdR[i][k];
            delete[] dphiNdz[i][k];
            delete[] dphiNdphi[i][k];
            delete[] modgradphiN[i][k];
            delete[] d2phiNdR2[i][k];
            delete[] d2phiNdz2[i][k];
            delete[] d2phiNdphi2[i][k];
            delete[] dnudR[i][k];
            delete[] dnudz[i][k];
            delete[] dnudphi[i][k];
            delete[] SQUMOND[i][k];
            delete[] phi0[i][k];
            delete[] phi1[i][k];
        }
    }

    delete[] phiNTheo;
    delete[] dphiNdR;
    delete[] dphiNdz;
    delete[] dphiNdphi;
    delete[] modgradphiN;
    delete[] d2phiNdR2;
    delete[] d2phiNdz2;
    delete[] d2phiNdphi2;
    delete[] dnudR;
    delete[] dnudz;
    delete[] dnudphi;
    delete[] SQUMOND;
    delete[] phi0;
    delete[] phi1;
    
    
    
    return 0;
}

// nu interpolating function

double nu(double y)
{
    double nu;
    //    There exist two types of nu interpolating functions, one in function of a parameter gamma and the other in function of a parameter delta. You have to choose the one you want to use and for which value of gamma or delta.
    //    Comment the parts that do not correspond to the nu function you want to use.
    double gamma;
    //    Simple nu-function (Eq. (4) of https://academic.oup.com/mnras/article/451/4/3551/1104023 with gamma = 1.0). Simple nu-function with gamma = 1.0 also corresponds to Eq. (17) in https://arxiv.org/abs/2003.07377:
    gamma = 1.0;
    //    Standard nu-function (Eq. (4) of https://academic.oup.com/mnras/article/451/4/3551/1104023 with gamma = 2.0):
    //    gamma = 2.0;
    //    You can choose another value for gamma
    //    gamma = ;

    nu = pow(0.5*(1.0 + sqrt(1.0 + 4.0*pow(y,-gamma))),1.0/gamma);

//    Eq. (5) of https://academic.oup.com/mnras/article/451/4/3551/1104023:
    //    double delta;
    //    Choose your delta
    //    delta = ;

    //    nu = pow(1.0 - exp(-pow(y,0.5*delta)),-1.0/delta) + (1.0 - 1.0/delta)*exp(-pow(y,0.5*delta));

    return nu;
}

////////////////////////////////////////////////////////////////////////
double Error(double ***V0, double ***V1)
//
// Compute error
////////////////////////////////////////////////////////////////////////
{
    double err;
    double err_L1  = 0.0;   // average relative error per lattice point
    double err_max = 0.0;

    for (int i = 0; i <= NR; i++)
    {
        for (int k = 0; k <= NZ; k++)
        {
            for (int j = 0; j < NPHI; j++)
            {
                err      = fabs(V1[i][k][j] - V0[i][k][j]); //(fabs(V0[i][j]) + 1.e-40);
                err_L1  += err;
                err_max  = (err > err_max ? err:err_max);
            }
        }
    }

    err_L1 /= (double)(NR - 1)*(NZ - 1)*(NPHI - 1);
    return err_L1;
}
////////////////////////////////////////////////////////////////////////

//double ErrorResiduo(double dR, double dR2, double dz2, double dphi2, double *R, double ***phi, double ***S) {
//    double residuo;
//    double residuo_L1 = 0.0;
//    double residuo_max = 0.0;
//
//    for (int i = 1; i < NR; i++) {
//        for (int k = 1; k < NZ; k++) {
//            for (int j = 0; j < NPHI; j++) {
//                int jplus  = (j + 1) % NPHI;
//                int jminus = (j - 1 + NPHI) % NPHI;
//
//                residuo = ( (1.0 + dR/(2.0*R[i]))*phi[i+1][k][j]
//                          + (1.0 - dR/(2.0*R[i]))*phi[i-1][k][j]
//                          + (dR2/(R[i]*R[i]*dphi2))*(phi[i][k][jplus] + phi[i][k][jminus])
//                          + (dR2/dz2)*(phi[i][k+1][j] + phi[i][k-1][j])
//                          - (2.0 + 2.0*dR2/dz2 + 2.0*dR2/(R[i]*R[i]*dphi2))*phi[i][k][j] ) / dR2
//                          + S[i][k][j];
//
//                residuo = fabs(residuo);
//
//                residuo_L1 += residuo;
//                residuo_max = (residuo > residuo_max) ? residuo : residuo_max;
//            }
//        }
//    }
//
//    residuo_L1 /= (double)((NR-1)*(NZ-1)*(NPHI));
//    return residuo_L1;
//}
